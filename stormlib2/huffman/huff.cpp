/*****************************************************************************/
/* huffman.cpp                       Copyright (c) Ladislav Zezula 1998-2003 */
/*---------------------------------------------------------------------------*/
/* This module contains Huffman (de)compression methods                     */
/*                                                                           */
/* Authors : Ladislav Zezula (ladik.zezula.net)                              */
/*           ShadowFlare     (BlakFlare@hotmail.com)                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/
/*   Date    Ver   Who  Comment                                              */
/* --------  ----  ---  -------                                              */
/* xx.xx.xx  1.00  Lad  The first version of dcmp.cpp                        */
/* 03.05.03  1.00  Lad  Added compression methods                            */
/* 19.11.03  1.01  Dan  Big endian handling                                  */
/* 08.12.03  2.01  Dan  High-memory handling (> 0x80000000)                  */
/*****************************************************************************/

#include <assert.h>
#include <string.h>
#include <CoreFoundation/CFByteOrder.h>

#include "huff.h"

#define PTR_NOT(ptr)                (THTreeItem *)(~(uintptr_t)(ptr))
#define PTR_PTR(ptr)                ((THTreeItem *)(ptr))
#define PTR_INT(ptr)                (intptr_t)(ptr)
#define PTR_VALID(ptr)              (((intptr_t)(ptr) * addr_multiplier) > 0)
#define PTR_INVALID(ptr)            (((intptr_t)(ptr) * addr_multiplier) < 0)
#define PTR_INVALID_OR_NULL(ptr)    (((intptr_t)(ptr) * addr_multiplier) < 0)

#define INSERT_ITEM 1                   
#define SWITCH_ITEMS 2 // Switch the item1 and item2

//-----------------------------------------------------------------------------
// Methods of the THTreeItem struct

// 1501DB70
THTreeItem * THTreeItem::Call1501DB70(THTreeItem * pLast)
{
    if(pLast == 0)
        pLast = this + 1;
    return pLast;
}

// Gets previous Huffman tree item (?)
THTreeItem * THTreeItem::GetPrevItem(intptr_t value)
{
    if(PTR_INVALID(prev))
        return PTR_NOT(prev);
    
    if(value == -1 || PTR_INVALID(value))
        value = (intptr_t)(this - next->prev);
    return prev + value;
}

// 1500F5E0
void THTreeItem::ClearItemLinks()
{
    next = prev = 0;
}

// 1500BC90
void THTreeItem::RemoveItem()
{
    THTreeItem * pTemp;                // EDX
 
    if(next != 0)
    {
        pTemp = prev;
       
        if(PTR_INVALID_OR_NULL(pTemp))
            pTemp = PTR_NOT(pTemp);
        else
            pTemp += (this - next->prev);
 
        pTemp->next = next;
        next->prev  = prev;
        next = prev = 0;
    }
}

//-----------------------------------------------------------------------------
// TOutputStream functions
 
void TOutputStream::PutBits(uint32_t dwBuff, uint32_t nPutBits)
{
    dwBitBuff |= (dwBuff << nBits);
    nBits     += nPutBits;
 
    // Flush completed bytes
    while(nBits >= 8)
    {
        if(dwOutSize != 0)
        {
            *pbOutPos++ = (uint8_t)dwBitBuff;
            dwOutSize--;
        }
 
        dwBitBuff >>= 8;
        nBits      -= 8;
    }
}
 
//-----------------------------------------------------------------------------
// TInputStream functions
 
// Gets one bit from input stream
uint32_t TInputStream::GetBit() {
    assert(buffer_bit_size + bit_count >= 1);
    
    if(bit_count == 0) {
        // The bucket is empty!
        assert(buffer_bit_size >= 8);
        
        if (buffer_bit_size >= 32) {
            bit_bucket = CFSwapInt32LittleToHost(*(uint32_t *)buffer);
            bit_count = 32;
            
            buffer += 4;
            buffer_bit_size -= 32;
        } else {
            bit_bucket = (uint32_t)*buffer;
            bit_count = 8;
            
            buffer++;
            buffer_bit_size -= 8;
        }
    }
    
    uint32_t bit = (bit_bucket & 1);
    bit_bucket >>= 1;
    bit_count--;
    
    return bit;
}

// Gets the whole byte from the input stream.
uint32_t TInputStream::Get8Bits() {
    assert(buffer_bit_size + bit_count >= 8);
    
    if(bit_count <= 8) {
        assert(buffer_bit_size >= 8);
        
        if (buffer_bit_size >= 16) {
            bit_bucket |= ((uint32_t)CFSwapInt16LittleToHost(*(uint16_t *)buffer)) << bit_count;
            bit_count += 16;
            
            buffer += 2;
            buffer_bit_size -= 16;
        } else {
            bit_bucket |= ((uint32_t)*buffer) << bit_count;
            bit_count += 8;
            
            buffer++;
            buffer_bit_size -= 8;
        }
    }
    
    uint32_t byte = (bit_bucket & 0xFF);
    bit_bucket >>= 8;
    bit_count -= 8;
    
    return byte;
}

// Peek 7 bits from the stream
uint32_t TInputStream::Peek7Bits() {
    assert(buffer_bit_size + bit_count >= 7);
    
    if(bit_count <= 7) {
        assert(buffer_bit_size >= 8);
        
        if (buffer_bit_size >= 16) {
            bit_bucket |= ((uint32_t)CFSwapInt16LittleToHost(*(uint16_t *)buffer)) << bit_count;
            bit_count += 16;
            
            buffer += 2;
            buffer_bit_size -= 16;
        } else {
            bit_bucket |= ((uint32_t)*buffer) << bit_count;
            bit_count += 8;
            
            buffer++;
            buffer_bit_size -= 8;
        }
    }

    // Get 7 bits from input stream
    return (bit_bucket & 0x7F);
}

void TInputStream::ConsumeBits(uint32_t count) {
    assert(buffer_bit_size + bit_count >= count);
    
    if (count <= bit_count) {
        bit_bucket >>= count;
        bit_count -= count;
    } else {
        // Drain the bit bucket
        count -= bit_count;
        bit_count = 0;
        buffer = 0;
        
        // Consume as many bytes out of the buffer
        uint32_t byte_count = count / 8;
        uint32_t extra_bits = count - (byte_count * 8);
        
        assert(buffer_bit_size >= byte_count * 8);
        buffer += byte_count;
        buffer_bit_size -= byte_count * 8U;
        
        // If there are extra bits, consume an extra byte out of the buffer and consume the bits
        if (extra_bits > 0) {
            assert(buffer_bit_size >= 8);

            bit_bucket = ((uint32_t)*buffer) >> extra_bits;
            bit_count = 8 - extra_bits;
            
            buffer++;
            buffer_bit_size -= 8;
        }
    }
}
 
//-----------------------------------------------------------------------------
// Functions for huffmann tree items
 
// Inserts item into the tree (?)
static void InsertItem(THTreeItem ** itemPtr, THTreeItem * item, uint32_t where, THTreeItem * item2)
{
    THTreeItem * next = item->next;             // EDI - next to the first item
    THTreeItem * prev = item->prev;             // ESI - prev to the first item
    THTreeItem * prev2;                         // Pointer to previous item
    intptr_t     next2;                         // Pointer to the next item
    intptr_t     addr_multiplier = item->addr_multiplier;
   
    // The same code like in RemoveItem(item);
    if(next != 0)                               // If the first item already has next one
    {
        if(PTR_INVALID(prev))
            prev = PTR_NOT(prev);
        else
            prev += (item - next->prev);
 
        // 150083C1
        // Remove the item from the tree
        prev->next = next;
        next->prev = prev;
 
        // Invalidate 'prev' and 'next' pointer
        item->next = 0;
        item->prev = 0;
    }
 
    if(item2 == 0)                              // EDX - If the second item is not entered,
        item2 = PTR_PTR(&itemPtr[1]);           // take the first tree item
 
    switch(where)
    {
        case SWITCH_ITEMS :                     // Switch the two items
            item->next  = item2->next;          // item2->next (Pointer to pointer to first)
            item->prev  = item2->next->prev;
            item2->next->prev = item;
            item2->next = item;                 // Set the first item
            return;
       
        case INSERT_ITEM:                       // Insert as the last item
            item->next = item2;                 // Set next item (or pointer to pointer to first item)
            item->prev = item2->prev;           // Set prev item (or last item in the tree)
 
            next2 = PTR_INT(itemPtr[0]);        // Usually 0
            prev2 = item2->prev;                // Prev item to the second (or last tree item)
           
            if(PTR_INVALID(prev2))
            {
                prev2 = PTR_NOT(prev);
 
                prev2->next = item;
                item2->prev = item;             // Next after last item
                return;
            }
 
            if(PTR_INVALID(next2))
                next2 = (intptr_t)(item2 - item2->next->prev);
//              next2 = (THTreeItem *)(unsigned long)((unsigned char *)item2 - (unsigned char *)(item2->next->prev));
 
//          prev2 = (THTreeItem *)((char *)prev2 + (unsigned long)next2);// ???
            prev2 += next2;
            prev2->next = item;
            item2->prev = item;                 // Set the next/last item
            return;
 
        default:
            return;
    }
}
 
//-----------------------------------------------------------------------------
// THuffmanTree class functions
 
THuffmanTree* THuffmanTree::AllocateTree() {
    THuffmanTree* instance = new THuffmanTree();
    if ((intptr_t)instance > 0 && (intptr_t)(instance + 1) < 0) {
        THuffmanTree* instance2 = new THuffmanTree();
        assert(!((intptr_t)instance2 > 0 && (intptr_t)(instance2 + 1) < 0));
        delete instance;
        instance = instance2;
    }
    return instance;
}

THuffmanTree::THuffmanTree()
{
    addr_multiplier = ((intptr_t)this < 0) ? -1 : 1;
}
 
void THuffmanTree::InitTree(bool bCompression)
{
    THTreeItem * pItem;
    uint32_t     nCount;
 
    // Clear links for all the items in the tree
    for(pItem = items0008, nCount = 0x203; nCount != 0; pItem++, nCount--)
    {
        pItem->ClearItemLinks();
        pItem->addr_multiplier = addr_multiplier;
    }
 
    pItem3050 = 0;
    pItem3054 = PTR_PTR(&pItem3054);
    pItem3058 = PTR_NOT(pItem3054);
   
    pItem305C = 0;
    pFirst    = PTR_PTR(&pFirst);
    pLast     = PTR_NOT(pFirst);
 
    offs0004  = 1;
    nItems    = 0;
 
    // Clear all TQDecompress items. Do this only if preparing for decompression
    if(bCompression == false)
    {
        for(nCount = 0; nCount < sizeof(qd3474) / sizeof(TQDecompress); nCount++)
            qd3474[nCount].offs00 = 0;
    }
}
 
// Builds Huffman tree. Called with the first 8 bits loaded from input stream
void THuffmanTree::BuildTree(uint32_t nCmpType)
{
    uint32_t        maxByte;                            // [ESP+10] - The greatest character found in table
    THTreeItem   ** itemPtr;                            // [ESP+14] - Pointer to Huffman tree item pointer array
    uint8_t       * byteArray;                          // [ESP+1C] - Pointer to unsigned char in Table1502A630
    THTreeItem    * child1;
    uint32_t        i;                                  // egcs in linux doesn't like multiple for loops without an explicit i
 
    // Loop while pointer has a valid value
    while(PTR_VALID(pLast))                             // ESI - Last entry
    {
        THTreeItem * temp;                              // EAX
 
        if(pLast->next != 0)                            // ESI->next
            pLast->RemoveItem();
                                                        // EDI = &offs3054
        pItem3058   = PTR_PTR(&pItem3054);              // [EDI+4]
        pLast->prev = pItem3058;                        // EAX
 
        temp = PTR_PTR(&pItem3054)->GetPrevItem(PTR_INT(&pItem3050));
 
        temp->next = pLast;
        pItem3054  = pLast;
    }
 
    // Clear all pointers in HTree item array
    memset(items306C, 0, sizeof(items306C));
 
    maxByte = 0;                                        // Greatest character found init to zero.
    itemPtr = (THTreeItem **)&items306C;                // Pointer to current entry in HTree item pointer array
 
    // Ensure we have low 8 bits only
    nCmpType &= 0xFF;
    byteArray  = Table1502A630 + nCmpType * 258;        // EDI also
 
    for(i = 0; i < 0x100; i++, itemPtr++)
    {
        THTreeItem * item   = pItem3058;                // Item to be created
        THTreeItem * pItem3 = pItem3058;
        uint8_t     oneByte = byteArray[i];
 
        // Skip all the bytes which are zero.
        if(byteArray[i] == 0)
            continue;
 
        // If not valid pointer, take the first available item in the array
        if(PTR_INVALID_OR_NULL(item))
            item = &items0008[nItems++];
 
        // Insert this item as the top of the tree
        InsertItem(&pItem305C, item, SWITCH_ITEMS, 0);
 
        item->parent    = 0;                            // Invalidate child and parent
        item->child     = 0;
        *itemPtr        = item;                         // Store pointer into pointer array
 
        item->dcmpByte  = i;                            // Store counter
        item->byteValue = oneByte;                      // Store byte value
        if(oneByte >= maxByte)
        {
            maxByte = oneByte;
            continue;
        }
 
        // Find the first item which has byte value greater than current one byte
        if(PTR_VALID(pItem3 = pLast))                   // EDI - Pointer to the last item
        {
            // 15006AF7
            if(pItem3 != 0)
            {
                do  // 15006AFB
                {
                    if(pItem3->byteValue >= oneByte)
                        goto _15006B09;
                    pItem3 = pItem3->prev;
                }
                while(PTR_VALID(pItem3));
            }
        }
        pItem3 = 0;
 
        // 15006B09
        _15006B09:
        if(item->next != 0)
            item->RemoveItem();
 
        // 15006B15
        if(pItem3 == 0)
            pItem3 = PTR_PTR(&pFirst);
 
        // 15006B1F
        item->next = pItem3->next;
        item->prev = pItem3->next->prev;
        pItem3->next->prev = item;
        pItem3->next = item;
    }
 
    // 15006B4A
    for(; i < 0x102; i++)
    {
        THTreeItem ** itemPtr = &items306C[i];          // EDI
 
        // 15006B59
        THTreeItem * item = pItem3058;                  // ESI
        if(PTR_INVALID_OR_NULL(item))
            item = &items0008[nItems++];
 
        InsertItem(&pItem305C, item, INSERT_ITEM, 0);
 
        // 15006B89
        item->dcmpByte   = i;
        item->byteValue  = 1;
        item->parent     = 0;
        item->child      = 0;
        *itemPtr++ = item;
    }
 
    // 15006BAA
    if(PTR_VALID(child1 = pLast))                       // EDI - last item (first child to item
    {
        THTreeItem * child2;                            // EBP
        THTreeItem * item;                              // ESI
 
        // 15006BB8
        while(PTR_VALID(child2 = child1->prev))
        {
            if(PTR_INVALID_OR_NULL(item = pItem3058))
                item = &items0008[nItems++];
 
            // 15006BE3
            InsertItem(&pItem305C, item, SWITCH_ITEMS, 0);
 
            // 15006BF3
            item->parent = 0;
            item->child  = 0;
 
            //EDX = child2->byteValue + child1->byteValue;
            //EAX = child1->byteValue;
            //ECX = maxByte;                                            // The greatest character (0xFF usually)
 
            item->byteValue = child1->byteValue + child2->byteValue;    // 0x02
            item->child     = child1;                                   // Prev item in the
            child1->parent  = item;
            child2->parent  = item;
 
            // EAX = item->byteValue;
            if(item->byteValue >= maxByte)
                maxByte = item->byteValue;
            else
            {
                THTreeItem * pItem2 = child2->prev;                     // EDI
 
                // 15006C2D
                while(PTR_VALID(pItem2))
                {
                    if(pItem2->byteValue >= item->byteValue)
                        goto _15006C3B;
                    pItem2 = pItem2->prev;
                }
                pItem2 = 0;
 
                _15006C3B:
                if(item->next != 0)
                {
                    THTreeItem * temp4 = item->GetPrevItem(-1);
                                                                   
                    temp4->next      = item->next;                      // The first item changed
                    item->next->prev = item->prev;                      // First->prev changed to negative value
                    item->next = 0;
                    item->prev = 0;
                }
 
                // 15006C62
                if(pItem2 == 0)
                    pItem2 = PTR_PTR(&pFirst);
 
                item->next = pItem2->next;                              // Set item with 0x100 byte value
                item->prev = pItem2->next->prev;                        // Set item with 0x17 byte value
                pItem2->next->prev = item;                              // Changed prev of item with
                pItem2->next = item;
            }

            // 15006C7B
            if(PTR_INVALID_OR_NULL(child1 = child2->prev))
                break;
        }
    }
    // 15006C88
    offs0004 = 1;
}
 
THTreeItem * THuffmanTree::Call1500E740(uint32_t nValue)
{
    THTreeItem * pItem1 = pItem3058;    // EDX
    THTreeItem * pItem2;                // EAX
    THTreeItem * pNext;
    THTreeItem * pPrev;
    THTreeItem ** ppItem;
 
    if(PTR_INVALID_OR_NULL(pItem1) || (pItem2 = pItem1) == 0)
    {
        if((pItem2 = &items0008[nItems++]) != 0)
            pItem1 = pItem2;
        else
            pItem1 = pFirst;
    }
    else
        pItem1 = pItem2;
 
    pNext = pItem1->next;
    if(pNext != 0)
    {
        pPrev = pItem1->prev;
        if(PTR_INVALID_OR_NULL(pPrev))
            pPrev = PTR_NOT(pPrev);
        else
            pPrev += (pItem1 - pItem1->next->prev);
 
        pPrev->next = pNext;
        pNext->prev = pPrev;
        pItem1->next = 0;
        pItem1->prev = 0;
    }
 
    ppItem = &pFirst;       // esi
    if(nValue > 1)
    {
        // ecx = pFirst->next;
        pItem1->next = *ppItem;
        pItem1->prev = (*ppItem)->prev;
 
        (*ppItem)->prev = pItem2;
        *ppItem = pItem1;
 
        pItem2->parent = 0;
        pItem2->child  = 0;
    }
    else
    {
        pItem1->next = (THTreeItem *)ppItem;
        pItem1->prev = ppItem[1];
        // edi = pItem305C;
        pPrev = ppItem[1];      // ecx
        if(PTR_INVALID_OR_NULL(pPrev))
        {
            pPrev = PTR_NOT(pPrev);
            pPrev->next = pItem1;
            pPrev->prev = pItem2;
 
            pItem2->parent = 0;
            pItem2->child  = 0;
        }
        else
        {
            if(PTR_INVALID(pItem305C))
                pPrev += (THTreeItem *)ppItem - (*ppItem)->prev;
            else
                pPrev += PTR_INT(pItem305C);
 
            pPrev->next    = pItem1;
            ppItem[1]      = pItem2;
            pItem2->parent = 0;
            pItem2->child  = 0;
        }
    }
    return pItem2;
}
 
void THuffmanTree::Call1500E820(THTreeItem * pItem)
{
    THTreeItem * pItem1;                // edi
    THTreeItem * pItem2 = 0;            // eax
    THTreeItem * pItem3;                // edx
    THTreeItem * pPrev;                 // ebx
 
    for(; pItem != 0; pItem = pItem->parent)
    {
        pItem->byteValue++;
       
        for(pItem1 = pItem; ; pItem1 = pPrev)
        {
            pPrev = pItem1->prev;
            if(PTR_INVALID_OR_NULL(pPrev))
            {
                pPrev = 0;
                break;
            }
 
            if(pPrev->byteValue >= pItem->byteValue)
                break;
        }
 
        if(pItem1 == pItem)
            continue;
 
        if(pItem1->next != 0)
        {
            pItem2 = pItem1->GetPrevItem(-1);
            pItem2->next = pItem1->next;
            pItem1->next->prev = pItem1->prev;
            pItem1->next = 0;
            pItem1->prev = 0;
        }
 
        pItem2 = pItem->next;
        pItem1->next = pItem2;
        pItem1->prev = pItem2->prev;
        pItem2->prev = pItem1;
        pItem->next = pItem1;
        if((pItem2 = pItem1) != 0)
        {
            pItem2 = pItem->GetPrevItem(-1);
            pItem2->next = pItem->next;
            pItem->next->prev = pItem->prev;
            pItem->next = 0;
            pItem->prev = 0;
        }
 
        if(pPrev == 0)
            pPrev = PTR_PTR(&pFirst);
 
        pItem2       = pPrev->next;
        pItem->next  = pItem2;
        pItem->prev  = pItem2->prev;
        pItem2->prev = pItem;
        pPrev->next  = pItem;
 
        pItem3 = pItem1->parent->child;
        pItem2 = pItem->parent;
        if(pItem2->child == pItem)
            pItem2->child = pItem1;
        if(pItem3 == pItem1)
            pItem1->parent->child = pItem;
 
        pItem2 = pItem->parent;
        pItem->parent  = pItem1->parent;
        pItem1->parent = pItem2;
        offs0004++;
    }
}
 
// 1500E920
uint32_t THuffmanTree::DoCompression(TOutputStream *os, uint8_t *pbInBuffer, int32_t nInLength, int32_t nCmpType)
{
    THTreeItem * pItem1;
    THTreeItem * pItem2;
    THTreeItem * pItem3;
    THTreeItem * pTemp;
    uint32_t     dwBitBuff;
    uint32_t     nBits;
    uint32_t     nBit;
 
    BuildTree(nCmpType);
    bIsCmp0 = (nCmpType == 0);
 
    // Store the compression type into output buffer
    os->dwBitBuff |= (nCmpType << os->nBits);
    os->nBits     += 8;
 
    // Flush completed bytes
    while(os->nBits >= 8)
    {
        if(os->dwOutSize != 0)
        {
            *os->pbOutPos++ = (uint8_t)os->dwBitBuff;
            os->dwOutSize--;
        }
 
        os->dwBitBuff >>= 8;
        os->nBits      -= 8;
    }
 
    for(; nInLength != 0; nInLength--)
    {
        uint8_t bOneByte = *pbInBuffer++;
 
        if((pItem1 = items306C[bOneByte]) == 0)
        {
            pItem2    = items306C[0x101];  // ecx
            pItem3    = pItem2->parent;    // eax
            dwBitBuff = 0;
            nBits     = 0;
 
            for(; pItem3 != 0; pItem3 = pItem3->parent)
            {
                nBit      = (pItem3->child != pItem2) ? 1 : 0;
                dwBitBuff = (dwBitBuff << 1) | nBit;
                nBits++;
                pItem2  = pItem3;
            }
            os->PutBits(dwBitBuff, nBits);
 
            // Store the loaded byte into output stream
            os->dwBitBuff |= (bOneByte << os->nBits);
            os->nBits     += 8;
 
            // Flush the whole byte(s)
            while(os->nBits >= 8)
            {
                if(os->dwOutSize != 0)
                {
                    *os->pbOutPos++ = (uint8_t)os->dwBitBuff;
                    os->dwOutSize--;
                }
                os->dwBitBuff >>= 8;
                os->nBits -= 8;
            }
 
            pItem1 = (PTR_INVALID_OR_NULL(pLast)) ? 0 : pLast;
            pItem2 = Call1500E740(1);
            pItem2->dcmpByte  = pItem1->dcmpByte;
            pItem2->byteValue = pItem1->byteValue;
            pItem2->parent    = pItem1;
            items306C[pItem2->dcmpByte] = pItem2;
 
            pItem2 = Call1500E740(1);
            pItem2->dcmpByte  = bOneByte;
            pItem2->byteValue = 0;
            pItem2->parent    = pItem1;
            items306C[pItem2->dcmpByte] = pItem2;
            pItem1->child = pItem2;
 
            Call1500E820(pItem2);
 
            if(bIsCmp0 != 0)
            {
                Call1500E820(items306C[bOneByte]);
                continue;
            }
 
            for(pItem1 = items306C[bOneByte]; pItem1 != 0; pItem1 = pItem1->parent)
            {
                pItem1->byteValue++;
                pItem2 = pItem1;
 
                for(;;)
                {
                    pItem3 = pItem2->prev;
                    if(PTR_INVALID_OR_NULL(pItem3))
                    {
                        pItem3 = 0;
                        break;
                    }
                    if(pItem3->byteValue >= pItem1->byteValue)
                        break;
                    pItem2 = pItem3;
                }
 
                if(pItem2 != pItem1)
                {
                    InsertItem(&pItem305C, pItem2, SWITCH_ITEMS, pItem1);
                    InsertItem(&pItem305C, pItem1, SWITCH_ITEMS, pItem3);
 
                    pItem3 = pItem2->parent->child;
                    if(pItem1->parent->child == pItem1)
                        pItem1->parent->child = pItem2;
 
                    if(pItem3 == pItem2)
                        pItem2->parent->child = pItem1;
 
                    pTemp = pItem1->parent;
                    pItem1->parent = pItem2->parent;
                    pItem2->parent = pTemp;
                    offs0004++;
                }
            }
        }
// 1500EB62
        else
        {
            dwBitBuff = 0;
            nBits = 0;
            for(pItem2 = pItem1->parent; pItem2 != 0; pItem2 = pItem2->parent)
            {
                nBit      = (pItem2->child != pItem1) ? 1 : 0;
                dwBitBuff = (dwBitBuff << 1) | nBit;
                nBits++;
                pItem1    = pItem2;
            }
            os->PutBits(dwBitBuff, nBits);
        }
 
// 1500EB98
        if(bIsCmp0 != 0)
            Call1500E820(items306C[bOneByte]);  // 1500EB9D
// 1500EBAF
    } // for(; nInLength != 0; nInLength--)
 
// 1500EBB8
    pItem1 = items306C[0x100];
    dwBitBuff = 0;
    nBits = 0;
    for(pItem2 = pItem1->parent; pItem2 != 0; pItem2 = pItem2->parent)
    {
        nBit      = (pItem2->child != pItem1) ? 1 : 0;
        dwBitBuff = (dwBitBuff << 1) | nBit;
        nBits++;
        pItem1    = pItem2;
    }
 
// 1500EBE6
    os->PutBits(dwBitBuff, nBits);
 
// 1500EBEF
    // Flush the remaining bits
    while(os->nBits != 0)
    {
        if(os->dwOutSize != 0)
        {
            *os->pbOutPos++ = (uint8_t)os->dwBitBuff;
            os->dwOutSize--;
        }
        os->dwBitBuff >>= 8;
        os->nBits -= ((os->nBits > 8) ? 8 : os->nBits);
    }
 
    return (uint32_t)(os->pbOutPos - os->pbOutBuffer);
}
 
// Decompression using Huffman tree (1500E450)
uint32_t THuffmanTree::DoDecompression(uint8_t *pbOutBuffer, uint32_t dwOutLength, TInputStream *is)
{
    TQDecompress  * qd;
    THTreeItem    * pItem1;
    THTreeItem    * pItem2;
    uint8_t       * pbOutPos = pbOutBuffer;
    uint32_t        nBitCount;
    uint32_t        nDcmpByte = 0;
    uint32_t        n8Bits;                // 8 bits loaded from input stream
    uint32_t        n7Bits;                // 7 bits loaded from input stream
    bool            bHasQdEntry;
   
    // Test the output length. Must not be 0.
    if(dwOutLength == 0)
        return 0;
 
    // Get the compression type from the input stream
    n8Bits = is->Get8Bits();
 
    // Build the Huffman tree
    BuildTree(n8Bits);    
    bIsCmp0 = (n8Bits == 0) ? 1 : 0;
 
    for(;;)
    {
        n7Bits = is->Peek7Bits();            // Get 7 bits from input stream
 
        // Try to use quick decompression. Check TQDecompress array for corresponding item.
        // If found, ise the result byte instead.
        qd = &qd3474[n7Bits];
 
        // If there is a quick-pass possible (ebx)
        bHasQdEntry = (qd->offs00 >= offs0004) ? true : false;
 
        // If we can use quick decompress, use it.
        if(bHasQdEntry)
        {
            if(qd->nBits > 7)
            {
                is->ConsumeBits(7);
                pItem1 = qd->pItem;
                goto _1500E549;
            }
            is->ConsumeBits(qd->nBits);
            nDcmpByte = qd->dcmpByte;
        }
        else
        {
            pItem1 = pFirst->next->prev;
            if(PTR_INVALID_OR_NULL(pItem1))
                pItem1 = 0;
_1500E549:           
            nBitCount = 0;
            pItem2 = 0;
 
            do
            {
                pItem1 = pItem1->child;     // Move down by one level
                if(is->GetBit())            // If current bit is set, move to previous
                    pItem1 = pItem1->prev;
 
                if(++nBitCount == 7)        // If we are at 7th bit, save current HTree item.
                    pItem2 = pItem1;
            }
            while(pItem1->child != 0);   // Walk until tree has no deeper level
 
            if(bHasQdEntry == false)
            {
                if(nBitCount > 7)
                {
                    qd->offs00 = offs0004;
                    qd->nBits  = nBitCount;
                    qd->pItem  = pItem2;
                }
                else
                {
                    uint32_t nIndex = n7Bits & (0xFFFFFFFF >> (32 - nBitCount));
                    uint32_t nAdd   = (1 << nBitCount);
                   
                    for(qd = &qd3474[nIndex]; nIndex <= 0x7F; nIndex += nAdd, qd += nAdd)
                    {
                        qd->offs00   = offs0004;
                        qd->nBits    = nBitCount;
                        qd->dcmpByte = pItem1->dcmpByte;
                    }
                }
            }
            nDcmpByte = pItem1->dcmpByte;
        }
 
        if(nDcmpByte == 0x101)          // Huffman tree needs to be modified
        {
            n8Bits = is->Get8Bits();
            pItem1 = (PTR_INVALID_OR_NULL(pLast)) ? 0 : pLast;
 
            pItem2 = Call1500E740(1);
            pItem2->parent    = pItem1;
            pItem2->dcmpByte  = pItem1->dcmpByte;
            pItem2->byteValue = pItem1->byteValue;
            items306C[pItem2->dcmpByte] = pItem2;
 
            pItem2 = Call1500E740(1);
            pItem2->parent    = pItem1;
            pItem2->dcmpByte  = n8Bits;
            pItem2->byteValue = 0;
            items306C[pItem2->dcmpByte] = pItem2;
 
            pItem1->child = pItem2;
            Call1500E820(pItem2);
            if(bIsCmp0 == 0)
                Call1500E820(items306C[n8Bits]);
 
            nDcmpByte = n8Bits;
        }
 
        if(nDcmpByte == 0x100)
            break;
 
        *pbOutPos++ = (uint8_t)nDcmpByte;
        if(--dwOutLength == 0)
            break;
 
        if(bIsCmp0)
            Call1500E820(items306C[nDcmpByte]);
    }
 
    return (uint32_t)(pbOutPos - pbOutBuffer);
}
 
// Table for (de)compression. Every compression type has 258 entries
uint8_t THuffmanTree::Table1502A630[] =
{
    // Data for compression type 0x00
    0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
    0x00, 0x00,
   
    // Data for compression type 0x01
    0x54, 0x16, 0x16, 0x0D, 0x0C, 0x08, 0x06, 0x05, 0x06, 0x05, 0x06, 0x03, 0x04, 0x04, 0x03, 0x05,
    0x0E, 0x0B, 0x14, 0x13, 0x13, 0x09, 0x0B, 0x06, 0x05, 0x04, 0x03, 0x02, 0x03, 0x02, 0x02, 0x02,
    0x0D, 0x07, 0x09, 0x06, 0x06, 0x04, 0x03, 0x02, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x02, 0x02,
    0x09, 0x06, 0x04, 0x04, 0x04, 0x04, 0x03, 0x02, 0x03, 0x02, 0x02, 0x02, 0x02, 0x03, 0x02, 0x04,
    0x08, 0x03, 0x04, 0x07, 0x09, 0x05, 0x03, 0x03, 0x03, 0x03, 0x02, 0x02, 0x02, 0x03, 0x02, 0x02,
    0x03, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01, 0x02, 0x01, 0x02, 0x02,
    0x06, 0x0A, 0x08, 0x08, 0x06, 0x07, 0x04, 0x03, 0x04, 0x04, 0x02, 0x02, 0x04, 0x02, 0x03, 0x03,
    0x04, 0x03, 0x07, 0x07, 0x09, 0x06, 0x04, 0x03, 0x03, 0x02, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02,
    0x0A, 0x02, 0x02, 0x03, 0x02, 0x02, 0x01, 0x01, 0x02, 0x02, 0x02, 0x06, 0x03, 0x05, 0x02, 0x03,
    0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x03, 0x01, 0x01, 0x01,
    0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x04, 0x04, 0x04, 0x07, 0x09, 0x08, 0x0C, 0x02,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x03,
    0x04, 0x01, 0x02, 0x04, 0x05, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01,
    0x04, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x01, 0x01, 0x02, 0x02, 0x02, 0x06, 0x4B,
    0x00, 0x00,
   
    // Data for compression type 0x02
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x27, 0x00, 0x00, 0x23, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x01, 0x01, 0x06, 0x0E, 0x10, 0x04,
    0x06, 0x08, 0x05, 0x04, 0x04, 0x03, 0x03, 0x02, 0x02, 0x03, 0x03, 0x01, 0x01, 0x02, 0x01, 0x01,
    0x01, 0x04, 0x02, 0x04, 0x02, 0x02, 0x02, 0x01, 0x01, 0x04, 0x01, 0x01, 0x02, 0x03, 0x03, 0x02,
    0x03, 0x01, 0x03, 0x06, 0x04, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x02, 0x01, 0x01,
    0x01, 0x29, 0x07, 0x16, 0x12, 0x40, 0x0A, 0x0A, 0x11, 0x25, 0x01, 0x03, 0x17, 0x10, 0x26, 0x2A,
    0x10, 0x01, 0x23, 0x23, 0x2F, 0x10, 0x06, 0x07, 0x02, 0x09, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00,
   
    // Data for compression type 0x03
    0xFF, 0x0B, 0x07, 0x05, 0x0B, 0x02, 0x02, 0x02, 0x06, 0x02, 0x02, 0x01, 0x04, 0x02, 0x01, 0x03,
    0x09, 0x01, 0x01, 0x01, 0x03, 0x04, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01,
    0x05, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x02, 0x01, 0x01, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01,
    0x0A, 0x04, 0x02, 0x01, 0x06, 0x03, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x01,
    0x05, 0x02, 0x03, 0x04, 0x03, 0x03, 0x03, 0x02, 0x01, 0x01, 0x01, 0x02, 0x01, 0x02, 0x03, 0x03,
    0x01, 0x03, 0x01, 0x01, 0x02, 0x05, 0x01, 0x01, 0x04, 0x03, 0x05, 0x01, 0x03, 0x01, 0x03, 0x03,
    0x02, 0x01, 0x04, 0x03, 0x0A, 0x06, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x02, 0x02, 0x01, 0x0A, 0x02, 0x05, 0x01, 0x01, 0x02, 0x07, 0x02, 0x17, 0x01, 0x05, 0x01, 0x01,
    0x0E, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x06, 0x02, 0x01, 0x04, 0x05, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01,
    0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x11,
    0x00, 0x00,
   
    // Data for compression type 0x04
    0xFF, 0xFB, 0x98, 0x9A, 0x84, 0x85, 0x63, 0x64, 0x3E, 0x3E, 0x22, 0x22, 0x13, 0x13, 0x18, 0x17,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00,
   
    // Data for compression type 0x05
    0xFF, 0xF1, 0x9D, 0x9E, 0x9A, 0x9B, 0x9A, 0x97, 0x93, 0x93, 0x8C, 0x8E, 0x86, 0x88, 0x80, 0x82,
    0x7C, 0x7C, 0x72, 0x73, 0x69, 0x6B, 0x5F, 0x60, 0x55, 0x56, 0x4A, 0x4B, 0x40, 0x41, 0x37, 0x37,
    0x2F, 0x2F, 0x27, 0x27, 0x21, 0x21, 0x1B, 0x1C, 0x17, 0x17, 0x13, 0x13, 0x10, 0x10, 0x0D, 0x0D,
    0x0B, 0x0B, 0x09, 0x09, 0x08, 0x08, 0x07, 0x07, 0x06, 0x05, 0x05, 0x04, 0x04, 0x04, 0x19, 0x18,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00,
   
    // Data for compression type 0x06
    0xC3, 0xCB, 0xF5, 0x41, 0xFF, 0x7B, 0xF7, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xBF, 0xCC, 0xF2, 0x40, 0xFD, 0x7C, 0xF7, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x7A, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00,
   
    // Data for compression type 0x07
    0xC3, 0xD9, 0xEF, 0x3D, 0xF9, 0x7C, 0xE9, 0x1E, 0xFD, 0xAB, 0xF1, 0x2C, 0xFC, 0x5B, 0xFE, 0x17,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xBD, 0xD9, 0xEC, 0x3D, 0xF5, 0x7D, 0xE8, 0x1D, 0xFB, 0xAE, 0xF0, 0x2C, 0xFB, 0x5C, 0xFF, 0x18,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x70, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00,
   
    // Data for compression type 0x08
    0xBA, 0xC5, 0xDA, 0x33, 0xE3, 0x6D, 0xD8, 0x18, 0xE5, 0x94, 0xDA, 0x23, 0xDF, 0x4A, 0xD1, 0x10,
    0xEE, 0xAF, 0xE4, 0x2C, 0xEA, 0x5A, 0xDE, 0x15, 0xF4, 0x87, 0xE9, 0x21, 0xF6, 0x43, 0xFC, 0x12,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xB0, 0xC7, 0xD8, 0x33, 0xE3, 0x6B, 0xD6, 0x18, 0xE7, 0x95, 0xD8, 0x23, 0xDB, 0x49, 0xD0, 0x11,
    0xE9, 0xB2, 0xE2, 0x2B, 0xE8, 0x5C, 0xDD, 0x15, 0xF1, 0x87, 0xE7, 0x20, 0xF7, 0x44, 0xFF, 0x13,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x5F, 0x9E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00
};
